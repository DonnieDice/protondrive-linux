# ProtonDrive Linux Client - Complete Project Context (Go Stack)

**Version**: 8.0 - STRATEGIC PIVOT  
**Last Updated**: 2024-12-09  
**Phase**: Project Restart - Technology Stack Change  
**Previous Stack**: TypeScript/Electron ‚Üí **New Stack**: Go/Fyne
**Project Health**: 10/10 (Better foundation chosen)

---

@./AGENT.md

---

## üîÑ STRATEGIC PIVOT ANNOUNCEMENT

**This project is pivoting from TypeScript/Electron to Go/Fyne.**

**Why the Pivot?**

1. **Proven Foundation**: Proton-API-Bridge (Go) already solves ProtonDrive API integration
2. **Better Performance**: Native Go binary vs Electron overhead
3. **Easier Distribution**: Single binary vs complex Electron packaging
4. **Lower Resource Usage**: 10-20MB RAM vs 80-150MB for Electron
5. **Community Support**: Active Go ProtonDrive ecosystem
6. **Simpler Stack**: Go is easier to learn and maintain than TypeScript + Node.js + Electron

**What This Means:**
- Restart project with Go
- Leverage existing Proton-API-Bridge
- Build native Linux client with Fyne GUI
- Much faster path to working product

---

## TABLE OF CONTENTS

1. [What This Document Is](#what-this-document-is)
2. [Project Overview](#project-overview)
3. [Architecture](#architecture-go-stack)
4. [Why Go Is Perfect](#why-go-is-perfect-for-this-project)
5. [Universal Hardware Compatibility](#universal-hardware-compatibility-go-approach)
6. [Project Structure](#project-structure-go)
7. [Development Patterns](#development-patterns)
8. [Migration Plan](#migration-plan-from-electron-project)
9. [Performance Budgets](#performance-budgets-go)
10. [Key Principles](#key-principles-updated-for-go)
11. [Agent Operational Rules](#agent-operational-rules)

---

## WHAT THIS DOCUMENT IS

This is the complete project context for building ProtonDrive Linux client in **Go**.

**Purpose**: Guide development of a native Linux client for ProtonDrive using Go and leveraging the existing Proton-API-Bridge.

**This document contains:**
- Project overview and goals
- Architecture decisions (Go-specific)
- Why Go over TypeScript/Electron
- Development patterns and best practices
- Migration plan from Electron
- **Agent operational rules and commands**

**This document does NOT contain:**
- Learning roadmaps (see separate learning docs)
- Task lists (see TASKS.md)
- User documentation (see README.md)

---

## PROJECT OVERVIEW

### What We're Building

ProtonDrive Linux is an unofficial, open-source desktop client for ProtonDrive targeting Linux users exclusively. **Native Go application** providing seamless file synchronization with ProtonDrive's zero-knowledge encryption.

**Critical Design Goal**: Universal hardware compatibility - runs on ANY Linux device (Raspberry Pi to workstations) with minimal resource usage.

### Why Go Instead of Electron

**Decision**: Use Go with Fyne GUI instead of TypeScript/Electron.

**Reasoning**:

| Aspect | Electron (Old) | Go + Fyne (New) | Winner |
|--------|----------------|-----------------|---------|
| **Binary Size** | 60-80MB | 10-20MB | üèÜ Go |
| **RAM Usage** | 80-150MB | 20-40MB | üèÜ Go |
| **Startup Time** | 1-2 seconds | <500ms | üèÜ Go |
| **Distribution** | Complex packaging | Single binary | üèÜ Go |
| **Cross-compile** | Difficult | Easy | üèÜ Go |
| **Learning Curve** | Steep (TS+Node+Electron) | Easier | üèÜ Go |
| **ProtonDrive Integration** | Build from scratch | Use Proton-API-Bridge | üèÜ Go |
| **Community** | General Electron | ProtonDrive-specific | üèÜ Go |

**The Killer Advantage**: Proton-API-Bridge already exists in Go and handles:
- ProtonDrive authentication
- File encryption/decryption
- API communication
- Rate limiting
- Error handling

We can build on top of this instead of reimplementing everything.

---

## PRIVACY PHILOSOPHY

**Core Principle**: User privacy is paramount.

ProtonDrive Linux is built with a strong commitment to user privacy and data security. As a fundamental architectural decision, **this application will NOT collect any local or application-level logs**.

This means:
- No telemetry data collection.
- No usage statistics are sent.
- No crash reports are generated automatically.
- All user data processing (e.g., file synchronization, encryption/decryption) occurs locally on the user's machine and is only transmitted to ProtonDrive servers in an encrypted form.

The only "logs" that may exist are those generated by the underlying operating system or standard Go runtime for debugging purposes during development, which are explicitly not considered part of the application's operational logging. Users are in full control of their data and its visibility.

---

## ARCHITECTURE (GO STACK)

### Overall Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         GUI (Fyne Framework)            ‚îÇ
‚îÇ   - Cross-platform native widgets       ‚îÇ
‚îÇ   - Lightweight (not web-based)         ‚îÇ
‚îÇ   - No JavaScript runtime               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ Direct Go function calls
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Application Logic (Go)          ‚îÇ
‚îÇ   - File synchronization                ‚îÇ
‚îÇ   - Conflict resolution                 ‚îÇ
‚îÇ   - Local state management              ‚îÇ
‚îÇ   - Performance profiling               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ Go API calls
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Proton-API-Bridge (Go Library)      ‚îÇ
‚îÇ   - ProtonDrive SDK integration         ‚îÇ
‚îÇ   - Authentication & encryption         ‚îÇ
‚îÇ   - API communication                   ‚îÇ
‚îÇ   - Rate limiting                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ HTTPS
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         ProtonDrive API                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Key Advantages vs Electron**:
- No IPC (Inter-Process Communication) needed
- No preload scripts or context isolation complexity
- Direct function calls between GUI and logic
- Single process, not multi-process like Electron
- Native performance throughout

---

## WHY GO IS PERFECT FOR THIS PROJECT

### 1. Built-in Concurrency

**Perfect for sync operations:**

```go
// Upload multiple files concurrently - built into language
func uploadFiles(files []string) {
    var wg sync.WaitGroup
    
    for _, file := range files {
        wg.Add(1)
        go func(f string) {
            defer wg.Done()
            uploadFile(f)
        }(file)
    }
    
    wg.Wait() // Wait for all uploads to complete
}
```

**Why This Matters**:
- File sync requires concurrent operations
- Go's goroutines are lightweight (2KB each)
- Can handle thousands of concurrent uploads/downloads
- Built into language, no external libraries needed

### 2. Single Binary Distribution

**Build once, run anywhere:**

```bash
# Build for current system
go build -o protondrive-linux

# Cross-compile for different architectures (ONE command)
GOOS=linux GOARCH=amd64 go build -o protondrive-linux-x64
GOOS=linux GOARCH=arm64 go build -o protondrive-linux-arm64
GOOS=linux GOARCH=arm go build -o protondrive-linux-armv7

# Result: Single 10-20MB binary
# No dependencies, no runtime needed
# Just copy and run
```

**Compare to Electron**:
- Electron: 60-80MB package + Node.js runtime + platform-specific installers
- Go: Single 10-20MB binary, works immediately

### 3. Resource Efficiency

**Memory footprint comparison:**

| Application | Idle RAM | Active RAM | Binary Size |
|-------------|----------|------------|-------------|
| Electron ProtonDrive | 80-100MB | 150-200MB | 60-80MB |
| **Go ProtonDrive** | **15-25MB** | **30-50MB** | **10-20MB** |

**Why this matters:**
- Runs on Raspberry Pi with 1GB RAM
- Multiple instances possible
- Battery efficient on laptops
- Fast startup (no V8 initialization)

### 4. Proton-API-Bridge Integration

**This is the game-changer:**

Instead of building from scratch:

```go
// Literally this simple with Proton-API-Bridge
import "github.com/henrybear327/Proton-API-Bridge/pkg/drive"

func main() {
    client := drive.NewClient()
    client.Login(username, password)
    
    files, _ := client.ListFiles("/")
    for _, file := range files {
        println(file.Name)
    }
}
```

vs TypeScript/Electron approach:
- Study ProtonDrive API docs
- Implement authentication (SRP protocol)
- Handle encryption/decryption
- Deal with API quirks
- Debug for weeks

Proton-API-Bridge: **Already done.**

### 5. Simplicity

**Go Philosophy**: "Less is more"

```go
// HTTP client in Go - standard library
package main

import (
    "net/http"
    "io"
    "os"
)

func main() {
    resp, _ := http.Get("https://example.com")
    defer resp.Body.Close()
    io.Copy(os.Stdout, resp.Body)
}
```

**No need for**:
- package.json
- webpack
- tsconfig.json
- node_modules (5000+ files)
- Complex build pipeline

**Just**: `go run main.go`

---

## UNIVERSAL HARDWARE COMPATIBILITY (GO APPROACH)

### Design Philosophy

**"If it runs Linux, it should run ProtonDrive Linux"**

Go makes this even easier than Electron:

### 1. Adaptive Resource Management

```go
// Detect system capabilities at startup
type SystemCapabilities struct {
    TotalRAM      uint64 // Bytes
    AvailableRAM  uint64 // Bytes
    CPUCores      int
    Architecture  string // amd64, arm64, arm
    StorageType   string // SSD, HDD, UNKNOWN
}

// Performance profiles
type PerformanceProfile interface {
    MaxConcurrentUploads() int
    MaxConcurrentDownloads() int
    CacheSizeMB() int
    ChunkSizeMB() int
}

type LowEndProfile struct{}
func (p LowEndProfile) MaxConcurrentUploads() int { return 1 }
func (p LowEndProfile) MaxConcurrentDownloads() int { return 2 }
func (p LowEndProfile) CacheSizeMB() int { return 50 }
func (p LowEndProfile) ChunkSizeMB() int { return 5 }

type StandardProfile struct{}
func (p StandardProfile) MaxConcurrentUploads() int { return 3 }
func (p StandardProfile) MaxConcurrentDownloads() int { return 5 }
func (p StandardProfile) CacheSizeMB() int { return 100 }
func (p StandardProfile) ChunkSizeMB() int { return 5 }

type HighEndProfile struct{}
func (p HighEndProfile) MaxConcurrentUploads() int { return 5 }
func (p HighEndProfile) MaxConcurrentDownloads() int { return 10 }
func (p HighEndProfile) CacheSizeMB() int { return 200 }
func (p HighEndProfile) ChunkSizeMB() int { return 10 }

func DetectProfile() PerformanceProfile {
    caps := detectSystemCapabilities()
    
    totalRAMMB := caps.TotalRAM / 1024 / 1024
    
    if totalRAMMB < 4096 {
        return LowEndProfile{}
    } else if totalRAMMB < 8192 {
        return StandardProfile{}
    }
    return HighEndProfile{}
}
```

### 2. Graceful Degradation

```go
// Adaptive concurrency
type SyncManager struct {
    profile PerformanceProfile
    uploadSem chan struct{} // Semaphore for uploads
}

func NewSyncManager(profile PerformanceProfile) *SyncManager {
    return &SyncManager{
        profile: profile,
        uploadSem: make(chan struct{}, profile.MaxConcurrentUploads()),
    }
}

func (sm *SyncManager) Upload(file string) error {
    sm.uploadSem <- struct{}{} // Acquire
    defer func() { <-sm.uploadSem }() // Release
    
    // Actual upload logic
    return uploadFile(file)
}
```

### 3. Storage Type Optimization

```go
func detectStorageType(path string) string {
    testFile := filepath.Join(path, ".storage-test")
    testData := make([]byte, 10*1024*1024) // 10MB
    
    start := time.Now()
    
    // Write test
    f, _ := os.Create(testFile)
    f.Write(testData)
    f.Sync() // Force flush to disk
    f.Close()
    
    duration := time.Since(start)
    os.Remove(testFile)
    
    // SSD: <100ms, HDD: >200ms for 10MB sync write
    if duration < 100*time.Millisecond {
        return "SSD"
    } else if duration > 150*time.Millisecond {
        return "HDD"
    }
    return "UNKNOWN"
}

// Adjust behavior
func optimizeForStorage(storageType string, db *sql.DB) {
    if storageType == "HDD" {
        // More aggressive batching for HDD
        db.Exec("PRAGMA synchronous = NORMAL")
        db.Exec("PRAGMA journal_mode = WAL")
        db.Exec("PRAGMA cache_size = -4000") // 4MB
    } else {
        db.Exec("PRAGMA synchronous = FULL")
        db.Exec("PRAGMA cache_size = -8000") // 8MB
    }
}
```

### 4. Multi-Architecture Support

```bash
# Build for all architectures
#!/bin/bash

# x86_64 (Intel/AMD)
GOOS=linux GOARCH=amd64 go build -o dist/protondrive-linux-x64

# ARM64 (Raspberry Pi 3+, modern ARM)
GOOS=linux GOARCH=arm64 go build -o dist/protondrive-linux-arm64

# ARMv7 (Raspberry Pi 2, older ARM)
GOOS=linux GOARCH=arm GOARM=7 go build -o dist/protondrive-linux-armv7

# ARMv6 (Raspberry Pi 1, very old ARM)
GOOS=linux GOARCH=arm GOARM=6 go build -o dist/protondrive-linux-armv6
```

**Result**: 4 binaries, each 10-20MB, ready to distribute.

---

## PROJECT STRUCTURE (GO)

```
protondrive-linux/
‚îú‚îÄ‚îÄ go.mod                    # Dependencies (like package.json)
‚îú‚îÄ‚îÄ go.sum                    # Dependency checksums
‚îú‚îÄ‚îÄ main.go                   # Entry point
‚îú‚îÄ‚îÄ cmd/                      # Command-line tools
‚îÇ   ‚îî‚îÄ‚îÄ protondrive/
‚îÇ       ‚îî‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ internal/                 # Private application code
‚îÇ   ‚îú‚îÄ‚îÄ sync/                # Sync engine
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manager.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ uploader.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ downloader.go
‚îÇ   ‚îú‚îÄ‚îÄ gui/                 # GUI components (Fyne)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ filelist.go
‚îÇ   ‚îú‚îÄ‚îÄ config/              # Configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ profiles.go
‚îÇ   ‚îú‚îÄ‚îÄ client/              # ProtonDrive client wrapper
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ client.go
‚îÇ   ‚îî‚îÄ‚îÄ storage/             # Local database
‚îÇ       ‚îú‚îÄ‚îÄ db.go
‚îÇ       ‚îî‚îÄ‚îÄ migrations.go
‚îú‚îÄ‚îÄ pkg/                     # Public libraries (if any)
‚îú‚îÄ‚îÄ scripts/                 # Build scripts
‚îÇ   ‚îî‚îÄ‚îÄ build-all.sh
‚îú‚îÄ‚îÄ docs/                    # Documentation
‚îú‚îÄ‚îÄ .agent_logs/             # AI agent logs
‚îú‚îÄ‚îÄ GEMINI.md               # This file
‚îú‚îÄ‚îÄ TASKS.md                # Task list
‚îî‚îÄ‚îÄ README.md               # User documentation
```

**Key Differences from Electron Structure**:
- No `src/main/`, `src/renderer/`, `src/preload/` split
- No `node_modules/` directory
- `internal/` for application code (private)
- `pkg/` for reusable libraries (public)
- `cmd/` for multiple binaries if needed

---

## DEVELOPMENT PATTERNS

### How to Implement a Service (Go Style)

```go
// internal/sync/manager.go
package sync

import (
    "context"
    "log"
    "sync"
)

// Manager handles file synchronization
type Manager struct {
    profile       PerformanceProfile
    client        *client.ProtonClient
    uploadQueue   chan string
    downloadQueue chan string
    wg            sync.WaitGroup
}

// NewManager creates a new sync manager
func NewManager(profile PerformanceProfile, client *client.ProtonClient) *Manager {
    return &Manager{
        profile:       profile,
        client:        client,
        uploadQueue:   make(chan string, 100),
        downloadQueue: make(chan string, 100),
    }
}

// Start begins sync operations
func (m *Manager) Start(ctx context.Context) error {
    log.Println("Starting sync manager")
    
    // Start upload workers
    for i := 0; i < m.profile.MaxConcurrentUploads(); i++ {
        m.wg.Add(1)
        go m.uploadWorker(ctx)
    }
    
    // Start download workers
    for i := 0; i < m.profile.MaxConcurrentDownloads(); i++ {
        m.wg.Add(1)
        go m.downloadWorker(ctx)
    }
    
    log.Println("Sync manager started")
    return nil
}

// Stop gracefully stops sync operations
func (m *Manager) Stop() {
    log.Println("Stopping sync manager")
    close(m.uploadQueue)
    close(m.downloadQueue)
    m.wg.Wait()
    log.Println("Sync manager stopped")
}

// QueueUpload adds file to upload queue
func (m *Manager) QueueUpload(filepath string) {
    m.uploadQueue <- filepath
}

// uploadWorker processes upload queue
func (m *Manager) uploadWorker(ctx context.Context) {
    defer m.wg.Done()
    
    for {
        select {
        case filepath, ok := <-m.uploadQueue:
            if !ok {
                return // Channel closed
            }
            
            log.Printf("Uploading: %s", filepath)
            if err := m.client.Upload(filepath); err != nil {
                log.Printf("Upload failed: %v", err)
            }
            
        case <-ctx.Done():
            return
        }
    }
}

// downloadWorker processes download queue
func (m *Manager) downloadWorker(ctx context.Context) {
    defer m.wg.Done()
    
    for {
        select {
        case filepath, ok := <-m.downloadQueue:
            if !ok {
                return // Channel closed
            }
            
            log.Printf("Downloading: %s", filepath)
            if err := m.client.Download(filepath); err != nil {
                log.Printf("Download failed: %v", err)
            }
            
        case <-ctx.Done():
            return
        }
    }
}
```

### How to Write Tests (Go Style)

```go
// internal/sync/manager_test.go
package sync

import (
    "context"
    "testing"
    "time"
)

// Mock client
type mockProtonClient struct {
    uploadCalled   int
    downloadCalled int
}

func (m *mockProtonClient) Upload(filepath string) error {
    m.uploadCalled++
    return nil
}

func (m *mockProtonClient) Download(filepath string) error {
    m.downloadCalled++
    return nil
}

func TestManagerStart(t *testing.T) {
    profile := StandardProfile{}
    mockClient := &mockProtonClient{}
    
    manager := NewManager(profile, mockClient)
    
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    if err := manager.Start(ctx); err != nil {
        t.Fatalf("Start failed: %v", err)
    }
    
    // Queue some uploads
    manager.QueueUpload("file1.txt")
    manager.QueueUpload("file2.txt")
    
    // Wait a bit for processing
    time.Sleep(100 * time.Millisecond)
    
    manager.Stop()
    
    if mockClient.uploadCalled != 2 {
        t.Errorf("Expected 2 uploads, got %d", mockClient.uploadCalled)
    }
}

func TestManagerConcurrency(t *testing.T) {
    profile := HighEndProfile{}
    mockClient := &mockProtonClient{}
    
    manager := NewManager(profile, mockClient)
    
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    manager.Start(ctx)
    
    // Queue many files
    for i := 0; i < 50; i++ {
        manager.QueueUpload("file.txt")
    }
    
    time.Sleep(500 * time.Millisecond)
    manager.Stop()
    
    if mockClient.uploadCalled != 50 {
        t.Errorf("Expected 50 uploads, got %d", mockClient.uploadCalled)
    }
}
```

**Run tests:**
```bash
go test ./...                    # All tests
go test -v ./internal/sync       # Verbose, specific package
go test -cover ./...             # With coverage
go test -race ./...              # Race detection
```

### Error Handling (Go Style)

```go
// internal/errors/errors.go
package errors

import "errors"

var (
    ErrAuthenticationFailed = errors.New("authentication failed")
    ErrNetworkTimeout      = errors.New("network timeout")
    ErrFileNotFound        = errors.New("file not found")
    ErrInvalidConfig       = errors.New("invalid configuration")
)

// Wrap errors with context
func WrapAuthentication(err error) error {
    return fmt.Errorf("authentication: %w", err)
}

func WrapNetwork(err error) error {
    return fmt.Errorf("network: %w", err)
}
```

**Usage:**
```go
func (c *ProtonClient) Login(username, password string) error {
    if err := c.api.Authenticate(username, password); err != nil {
        return errors.WrapAuthentication(err)
    }
    return nil
}

// In caller
if err := client.Login(username, password); err != nil {
    if errors.Is(err, errors.ErrAuthenticationFailed) {
        // Handle auth error specifically
    }
    return err
}
```

---

## MIGRATION PLAN FROM ELECTRON PROJECT

### What to Keep

From the existing TypeScript/Electron project:

‚úÖ **Keep these concepts**:
- Overall architecture decisions (security, privacy)
- Universal hardware compatibility philosophy
- Performance profiling concepts
- Documentation structure
- Testing philosophy (80% coverage)
- Git workflow

‚úÖ **Keep these files**:
- `README.md` (update tech stack section)
- `LICENSE`
- `SECURITY.md`
- `CODE_OF_CONDUCT.md`
- `.gitignore` (update for Go)
- `docs/` directory content
- This file (GEMINI.md - already updated)

### What to Remove

‚ùå **Delete Electron-specific files**:
```bash
rm -rf node_modules/
rm package.json package-lock.json
rm tsconfig.json
rm webpack.config.js
rm forge.config.js
rm -rf src/
rm .eslintrc.json
rm .prettierrc
rm jest.config.js
```

### What to Create

‚úÖ **Create Go-specific files**:
```bash
# Initialize Go module
go mod init github.com/yourusername/protondrive-linux

# Create project structure
mkdir -p cmd/protondrive
mkdir -p internal/{sync,gui,config,client,storage}
mkdir -p pkg
mkdir -p scripts

# Create main.go
touch main.go
touch cmd/protondrive/main.go

# Add dependencies
go get github.com/henrybear327/Proton-API-Bridge
go get fyne.io/fyne/v2
go get github.com/mattn/go-sqlite3
```

### Migration Steps

```bash
# 1. Backup existing project
git checkout -b electron-backup
git commit -am "Backup Electron version before Go pivot"
git push origin electron-backup

# 2. Create Go branch
git checkout main
git checkout -b go-pivot

# 3. Clean Electron files
rm -rf node_modules src package*.json tsconfig.json webpack.config.js forge.config.js

# 4. Initialize Go
go mod init github.com/yourusername/protondrive-linux

# 5. Create structure
mkdir -p cmd/protondrive internal/{sync,gui,config,client,storage} pkg scripts

# 6. Add dependencies
go get github.com/henrybear327/Proton-API-Bridge
go get fyne.io/fyne/v2
go get github.com/mattn/go-sqlite3

# 7. Update .gitignore
cat >> .gitignore << 'EOF'

# Go
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
*.out
go.work
dist/
vendor/
EOF

# 8. Create initial main.go
cat > main.go << 'EOF'
package main

import "fmt"

func main() {
    fmt.Println("ProtonDrive Linux - Go Edition")
}
EOF

# 9. Test build
go build -o protondrive-linux

# 10. Commit
git add .
git commit -m "feat: pivot to Go/Fyne stack"
git push origin go-pivot
```

---

## PERFORMANCE BUDGETS (GO)

### Startup Time
- **Cold start**: < 500ms (was 2s for Electron)
- **Warm start**: < 200ms (was 1s for Electron)

### Memory Usage
- **Low-end profile**: < 30MB (was 100MB)
- **Standard profile**: < 50MB (was 150MB)
- **High-end profile**: < 80MB (was 200MB)

### Binary Size
- **Single binary**: < 20MB (was 60-80MB)
- **No unpacking needed** (Electron required 200MB unpacked)

### UI Performance
- **FPS**: 60 on all hardware (native rendering)
- **First paint**: < 100ms (was 500ms)
- **Time to interactive**: < 500ms (was 1.5s)

---

## KEY PRINCIPLES (UPDATED FOR GO)

1. **Universal Compatibility**: Must run on any Linux device
2. **Adaptive Performance**: Adjust to available hardware
3. **Leverage Existing Work**: Build on Proton-API-Bridge
4. **Native Performance**: No V8/Chromium overhead
5. **Simple Distribution**: Single binary
6. **Test Coverage**: 80% minimum on all code
7. **Documentation**: GoDoc on all public APIs
8. **Graceful Degradation**: Never fail hard, reduce features instead

---

## AGENT OPERATIONAL RULES

### Overview

This section defines how AI agents (Claude, Gemini, GPT-4, etc.) should interact with this project.

### Core Responsibilities

**As an agent working on ProtonDrive Linux, you must:**

1. **Maintain Context**: Always read GEMINI.md before starting work
2. **Follow Architecture**: Respect the Go/Fyne stack decisions
3. **Document Changes**: Update relevant documentation when making changes
4. **Test Your Code**: Write tests for new functionality (80% coverage minimum)
5. **Preserve Intent**: Keep the universal hardware compatibility philosophy
6. **Log Your Actions**: Document significant decisions in `.agent_logs/`

### Project Commands (Go Version)

```bash
# Setup
go mod download              # Install dependencies
go mod tidy                 # Clean up dependencies

# Development
go run main.go              # Run application
go build -o protondrive     # Build binary
go test ./...               # Run all tests
go test -v ./internal/sync  # Run specific package tests
go test -cover ./...        # Test with coverage
go test -race ./...         # Test with race detection

# Code Quality
go fmt ./...                # Format code
go vet ./...                # Static analysis
golangci-lint run           # Comprehensive linting

# Build for Multiple Architectures
./scripts/build-all.sh      # Build for all Linux architectures

# Documentation
go doc ./internal/sync      # View package documentation
godoc -http=:6060           # Start documentation server
```

### Communication Protocol

**When asking for help or clarification:**

1. **Be Specific**: "I need help implementing X in internal/sync/manager.go"
2. **Provide Context**: Reference relevant parts of GEMINI.md
3. **Show What You've Tried**: Share code snippets or error messages
4. **Ask Focused Questions**: One issue at a time

**When reporting progress:**

1. **Update TASKS.md**: Mark completed tasks
2. **Log Decisions**: Add entry to `.agent_logs/`
3. **Update Documentation**: If architecture changes
4. **Commit with Clear Messages**: Follow conventional commits

### Decision-Making Authority

**You CAN decide on:**
- Implementation details within established patterns
- Variable/function names following Go conventions
- Test structure and test data
- Code organization within packages
- Performance optimizations that maintain compatibility

**You MUST ask before:**
- Changing project architecture
- Adding new major dependencies
- Modifying performance profiles
- Changing build/distribution strategy
- Altering API contracts
- Removing features

### Code Style Guide (Go)

```go
// GOOD: Go idiomatic style
func (m *Manager) Start(ctx context.Context) error {
    log.Println("Starting sync manager")
    
    for i := 0; i < m.profile.MaxConcurrentUploads(); i++ {
        m.wg.Add(1)
        go m.uploadWorker(ctx)
    }
    
    return nil
}

// BAD: Not Go idiomatic
func (m *Manager) Start(ctx context.Context) error {
    log.Println("Starting sync manager");
    
    for (i := 0; i < m.profile.MaxConcurrentUploads(); i++) {
        m.wg.Add(1);
        go m.uploadWorker(ctx);
    }
    
    return nil;
}
```

**Go Style Rules:**
- No semicolons (unless required)
- Use `gofmt` formatting
- Short variable names in small scopes (`i`, `err`, `ctx`)
- Descriptive names in larger scopes
- Exported names start with capital letter
- Package names are lowercase, single word
- Interface names end with `-er` (Reader, Writer, Manager)
- Error handling with explicit `if err != nil`
- Defer for cleanup

### Error Handling Pattern

```go
// GOOD: Explicit error handling
func processFile(path string) error {
    f, err := os.Open(path)
    if err != nil {
        return fmt.Errorf("open file: %w", err)
    }
    defer f.Close()
    
    data, err := io.ReadAll(f)
    if err != nil {
        return fmt.Errorf("read file: %w", err)
    }
    
    return processData(data)
}

// BAD: Ignoring errors
func processFile(path string) error {
    f, _ := os.Open(path)  // DON'T IGNORE ERRORS
    data, _ := io.ReadAll(f)
    processData(data)
    return nil
}
```

### Testing Requirements

**Every new feature must include:**

1. **Unit Tests**: Test individual functions/methods
2. **Integration Tests**: Test component interactions
3. **Benchmark Tests**: For performance-critical code
4. **Example Tests**: For public APIs

```go
// Unit test
func TestManagerStart(t *testing.T) {
    // Test implementation
}

// Benchmark test
func BenchmarkUpload(b *testing.B) {
    for i := 0; i < b.N; i++ {
        uploadFile("test.txt")
    }
}

// Example test (appears in godoc)
func ExampleManager_Start() {
    manager := NewManager(StandardProfile{}, client)
    manager.Start(context.Background())
    // Output: Starting sync manager
}
```

### Documentation Requirements

**Every exported symbol must have a doc comment:**

```go
// Manager handles file synchronization between local storage
// and ProtonDrive. It manages upload/download queues and
// coordinates multiple concurrent operations based on the
// configured performance profile.
type Manager struct {
    profile PerformanceProfile
    client  *client.ProtonClient
}

// NewManager creates a new sync manager with the given profile
// and ProtonDrive client. The manager must be started with
// Start() before it will process any files.
func NewManager(profile PerformanceProfile, client *client.ProtonClient) *Manager {
    return &Manager{
        profile: profile,
        client:  client,
    }
}
```

### Git Workflow

**Commit Message Format:**
```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types:**
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes (formatting)
- `refactor`: Code refactoring
- `perf`: Performance improvements
- `test`: Test additions/changes
- `chore`: Build/tooling changes

**Examples:**
```bash
feat(sync): implement adaptive upload concurrency

- Added profile-based upload semaphore
- Detects system RAM and adjusts concurrency
- Tested on 1GB, 4GB, and 8GB systems

Closes #23

---

fix(client): handle authentication timeout gracefully

- Added 30s timeout to auth requests
- Retry with exponential backoff
- Better error messages

Fixes #45
```

### Logging Pattern

```go
import "log"

// Use standard library log package
log.Println("Starting operation")          // Info
log.Printf("Processing file: %s", path)    // Info with formatting
log.Fatal("Critical error:", err)          // Fatal (exits)

// For structured logging (optional: use slog in Go 1.21+)
import "log/slog"

slog.Info("operation started",
    "user", username,
    "files", fileCount,
)

slog.Error("upload failed",
    "file", filepath,
    "error", err,
)
```

### Performance Profiling

```go
// CPU Profiling
import _ "net/http/pprof"

go func() {
    log.Println(http.ListenAndServe("localhost:6060", nil))
}()

// Memory Profiling
var memStats runtime.MemStats
runtime.ReadMemStats(&memStats)
log.Printf("Alloc = %v MiB", memStats.Alloc / 1024 / 1024)

// Benchmark with profiling
go test -bench=. -cpuprofile=cpu.prof -memprofile=mem.prof
go tool pprof cpu.prof
```

### Agent Session Logging

**Create log entry for each session:**

```bash
# .agent_logs/2024-12-09-session-001.md
```

```markdown
# Agent Session Log

**Date**: 2024-12-09
**Agent**: Claude-3.5-Sonnet
**Duration**: 2 hours
**Focus**: Initial Go project setup

## Objectives
- Initialize Go module
- Set up project structure
- Integrate Proton-API-Bridge
- Create basic main.go

## Actions Taken
1. Created go.mod with module path
2. Set up internal/ structure for sync, gui, config packages
3. Added Proton-API-Bridge dependency
4. Implemented basic profile detection
5. Created initial tests

## Decisions Made
- Used sync.WaitGroup for goroutine coordination
- Chose buffered channels with size 100 for queues
- Decided on 3-tier profile system (Low/Standard/High)

## Issues Encountered
- Proton-API-Bridge documentation sparse
- Had to examine source code for API usage
- SQLite driver requires CGO

## Next Steps
- Implement file watcher
- Create GUI login screen
- Test on Raspberry Pi

## Files Modified
- go.mod, go.sum
- internal/sync/manager.go
- internal/config/profiles.go
- TASKS.md (marked Phase 1 tasks complete)
```

### Working with Dependencies

```bash
# Add dependency
go get github.com/some/package

# Update dependency
go get -u github.com/some/package

# Update all dependencies
go get -u ./...

# Remove unused dependencies
go mod tidy

# Vendor dependencies (optional)
go mod vendor

# Check for updates
go list -m -u all
```

### Build Tags and Conditional Compilation

```go
//go:build linux
// +build linux

package main

// This file only compiles on Linux

import "syscall"

func getPlatformInfo() string {
    var utsname syscall.Utsname
    syscall.Uname(&utsname)
    return string(utsname.Sysname[:])
}
```

### Cross-Compilation Tips

```bash
# Check available platforms
go tool dist list

# Build for specific platform
GOOS=linux GOARCH=arm64 go build

# Build with custom flags
go build -ldflags="-s -w" -o protondrive  # Strip symbols, reduce size

# Build with version info
VERSION=$(git describe --tags)
go build -ldflags="-X main.Version=$VERSION"
```

### Dependency Management Philosophy

**Prefer:**
- Standard library when possible
- Well-maintained, popular libraries
- Minimal dependency trees
- Pure Go libraries (avoid CGO when possible)

**Avoid:**
- Abandoned libraries
- Libraries with many transitive dependencies
- Libraries requiring system libraries
- Overengineered solutions

**Current Dependencies:**
- `github.com/henrybear327/Proton-API-Bridge` - ProtonDrive integration
- `fyne.io/fyne/v2` - GUI framework
- `github.com/mattn/go-sqlite3` - Database (CGO required)

### Troubleshooting Common Issues

**Issue: CGO_ENABLED=1 required for SQLite**
```bash
# Solution: Install GCC/build tools
sudo apt-get install build-essential  # Debian/Ubuntu
sudo yum install gcc                   # RHEL/CentOS

# Or use pure Go alternative
go get modernc.org/sqlite  # Pure Go SQLite
```

**Issue: Fyne build fails**
```bash
# Solution: Install development libraries
sudo apt-get install libgl1-mesa-dev xorg-dev  # Debian/Ubuntu
```

**Issue: Cross-compilation fails**
```bash
# Solution: Set CGO_ENABLED=0 for pure Go builds
CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build
```

### Success Criteria

**Before considering a feature "done":**

- [ ] Code compiles without warnings
- [ ] All tests pass (`go test ./...`)
- [ ] Test coverage ‚â•80% for new code
- [ ] No race conditions (`go test -race ./...`)
- [ ] Code formatted (`go fmt ./...`)
- [ ] No lint errors (`golangci-lint run`)
- [ ] Documentation complete (godoc)
- [ ] TASKS.md updated
- [ ] Agent log created
- [ ] Git commit with proper message

### Communication Examples

**Good Agent Response:**
```
I've implemented the upload queue in internal/sync/manager.go.

What I did:
- Created buffered channel with capacity 100
- Implemented worker pool pattern
- Added graceful shutdown with WaitGroup
- Wrote tests achieving 85% coverage

Files modified:
- internal/sync/manager.go (new)
- internal/sync/manager_test.go (new)
- go.mod (added testify dependency)

Next steps:
- Implement download queue (similar pattern)
- Add retry logic for failed uploads
- Test on low-end hardware

Ready for review. Should I proceed with download queue?
```

**Bad Agent Response:**
```
Done. Added upload stuff. Works now.
```

### When to Ask for Help

**Ask immediately if:**
- Architecture change seems necessary
- Performance budget might be violated
- Major dependency needed
- Breaking change required
- Security concern discovered
- Platform compatibility issue found

**Don't ask for:**
- Variable name choices
- Standard Go idioms
- Test data generation
- Code formatting decisions
- Import organization

### Project Health Indicators

**Green (10/10):**
- All tests passing
- Coverage ‚â•80%
- No lint errors
- Documentation complete
- Builds on all targets

**Yellow (6-9/10):**
- Some tests failing
- Coverage 60-79%
- Minor lint issues
- Some docs missing
- Builds on most targets

**Red (0-5/10):**
- Many tests failing
- Coverage <60%
- Major lint issues
- No documentation
- Doesn't build

**Current Status**: 10/10 (Fresh start with solid foundation)

---

## SUCCESS METRICS

**Go version is successful when**:
- ‚úÖ Binary < 20MB
- ‚úÖ RAM usage < 50MB under normal operation
- ‚úÖ Startup < 500ms
- ‚úÖ Successfully authenticates with ProtonDrive
- ‚úÖ Can list, upload, download files
- ‚úÖ Runs on Raspberry Pi with 1GB RAM
- ‚úÖ Single binary distribution works
- ‚úÖ 80% test coverage maintained

---

**For Task Management**: See TASKS.md  
**For User Documentation**: See README.md (update tech stack)